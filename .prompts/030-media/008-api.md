# Stage 8: OpenAPI + HTTP Handlers

<objective>
Add media endpoints to the OpenAPI specification and implement HTTP handlers for file upload, download, and management.
</objective>

<context>
Reference existing patterns in:
- @file:internal/api/openapi.yaml - OpenAPI 3.0 spec structure, tags, schemas
- @file:internal/api/handlers.go - Echo handler patterns, response helpers

Dependencies:
- Stages 1-7 complete (domain through thumbnail generation)
</context>

<requirements>

## 1. OpenAPI Specification Updates

Add to `internal/api/openapi.yaml`:

### Tags Section
```yaml
tags:
  # ... existing tags ...
  - name: media
    description: Media file management (photos, documents)
```

### Paths

```yaml
paths:
  # ... existing paths ...

  /persons/{id}/media:
    parameters:
      - $ref: '#/components/parameters/personId'

    get:
      operationId: listPersonMedia
      summary: List media attached to a person
      tags: [media]
      parameters:
        - $ref: '#/components/parameters/limitParam'
        - $ref: '#/components/parameters/offsetParam'
      responses:
        '200':
          description: List of media
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/MediaList'
        '404':
          $ref: '#/components/responses/NotFound'

    post:
      operationId: uploadPersonMedia
      summary: Upload media for a person
      tags: [media]
      requestBody:
        required: true
        content:
          multipart/form-data:
            schema:
              $ref: '#/components/schemas/MediaUpload'
      responses:
        '201':
          description: Media uploaded
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/Media'
        '400':
          $ref: '#/components/responses/BadRequest'
        '413':
          description: File too large
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/Error'

  /families/{id}/media:
    parameters:
      - $ref: '#/components/parameters/familyId'

    get:
      operationId: listFamilyMedia
      summary: List media attached to a family
      tags: [media]
      parameters:
        - $ref: '#/components/parameters/limitParam'
        - $ref: '#/components/parameters/offsetParam'
      responses:
        '200':
          description: List of media
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/MediaList'
        '404':
          $ref: '#/components/responses/NotFound'

    post:
      operationId: uploadFamilyMedia
      summary: Upload media for a family
      tags: [media]
      requestBody:
        required: true
        content:
          multipart/form-data:
            schema:
              $ref: '#/components/schemas/MediaUpload'
      responses:
        '201':
          description: Media uploaded
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/Media'
        '400':
          $ref: '#/components/responses/BadRequest'
        '413':
          description: File too large

  /media/{id}:
    parameters:
      - name: id
        in: path
        required: true
        schema:
          type: string
          format: uuid

    get:
      operationId: getMedia
      summary: Get media metadata
      tags: [media]
      responses:
        '200':
          description: Media metadata
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/Media'
        '404':
          $ref: '#/components/responses/NotFound'

    put:
      operationId: updateMedia
      summary: Update media metadata
      tags: [media]
      requestBody:
        required: true
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/MediaUpdate'
      responses:
        '200':
          description: Media updated
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/Media'
        '400':
          $ref: '#/components/responses/BadRequest'
        '404':
          $ref: '#/components/responses/NotFound'
        '409':
          $ref: '#/components/responses/Conflict'

    delete:
      operationId: deleteMedia
      summary: Delete media
      tags: [media]
      responses:
        '204':
          description: Media deleted
        '404':
          $ref: '#/components/responses/NotFound'

  /media/{id}/download:
    parameters:
      - name: id
        in: path
        required: true
        schema:
          type: string
          format: uuid

    get:
      operationId: downloadMedia
      summary: Download media file
      tags: [media]
      responses:
        '200':
          description: Media file
          content:
            application/octet-stream:
              schema:
                type: string
                format: binary
          headers:
            Content-Disposition:
              schema:
                type: string
                example: 'attachment; filename="photo.jpg"'
            Content-Type:
              schema:
                type: string
                example: 'image/jpeg'
        '404':
          $ref: '#/components/responses/NotFound'

  /media/{id}/thumbnail:
    parameters:
      - name: id
        in: path
        required: true
        schema:
          type: string
          format: uuid

    get:
      operationId: getMediaThumbnail
      summary: Get media thumbnail
      tags: [media]
      responses:
        '200':
          description: Thumbnail image (JPEG)
          content:
            image/jpeg:
              schema:
                type: string
                format: binary
        '404':
          $ref: '#/components/responses/NotFound'
```

### Schemas

```yaml
components:
  schemas:
    # ... existing schemas ...

    MediaType:
      type: string
      enum: [photo, document, audio, video, certificate]

    Media:
      type: object
      required: [id, entity_type, entity_id, title, mime_type, media_type, filename, file_size, version]
      properties:
        id:
          type: string
          format: uuid
        entity_type:
          type: string
          enum: [person, family, source]
        entity_id:
          type: string
          format: uuid
        title:
          type: string
          maxLength: 500
        description:
          type: string
        mime_type:
          type: string
        media_type:
          $ref: '#/components/schemas/MediaType'
        filename:
          type: string
        file_size:
          type: integer
          format: int64
        has_thumbnail:
          type: boolean
        crop_left:
          type: integer
        crop_top:
          type: integer
        crop_width:
          type: integer
        crop_height:
          type: integer
        version:
          type: integer
          format: int64
        created_at:
          type: string
          format: date-time
        updated_at:
          type: string
          format: date-time

    MediaUpload:
      type: object
      required: [file, title]
      properties:
        file:
          type: string
          format: binary
          description: The media file to upload (max 10MB)
        title:
          type: string
          maxLength: 500
          description: Display title for the media
        description:
          type: string
          description: Optional description

    MediaUpdate:
      type: object
      required: [version]
      properties:
        title:
          type: string
          maxLength: 500
        description:
          type: string
        media_type:
          $ref: '#/components/schemas/MediaType'
        crop_left:
          type: integer
        crop_top:
          type: integer
        crop_width:
          type: integer
        crop_height:
          type: integer
        version:
          type: integer
          format: int64
          description: Current version for optimistic locking

    MediaList:
      type: object
      required: [items, total]
      properties:
        items:
          type: array
          items:
            $ref: '#/components/schemas/Media'
        total:
          type: integer
        limit:
          type: integer
        offset:
          type: integer
```

## 2. HTTP Handler Implementation

Add to `internal/api/handlers.go` (or create `internal/api/media_handlers.go`):

```go
// ListPersonMedia handles GET /persons/{id}/media
func (h *Handler) ListPersonMedia(c echo.Context) error {
    return h.listEntityMedia(c, "person")
}

// ListFamilyMedia handles GET /families/{id}/media
func (h *Handler) ListFamilyMedia(c echo.Context) error {
    return h.listEntityMedia(c, "family")
}

func (h *Handler) listEntityMedia(c echo.Context, entityType string) error {
    id, err := uuid.Parse(c.Param("id"))
    if err != nil {
        return errorResponse(c, http.StatusBadRequest, "INVALID_ID", "Invalid UUID format")
    }

    opts := parseListOptions(c)
    items, total, err := h.readStore.ListMediaForEntity(c.Request().Context(), entityType, id, opts)
    if err != nil {
        return errorResponse(c, http.StatusInternalServerError, "INTERNAL_ERROR", err.Error())
    }

    return c.JSON(http.StatusOK, map[string]any{
        "items":  items,
        "total":  total,
        "limit":  opts.Limit,
        "offset": opts.Offset,
    })
}

// UploadPersonMedia handles POST /persons/{id}/media
func (h *Handler) UploadPersonMedia(c echo.Context) error {
    return h.uploadEntityMedia(c, "person")
}

// UploadFamilyMedia handles POST /families/{id}/media
func (h *Handler) UploadFamilyMedia(c echo.Context) error {
    return h.uploadEntityMedia(c, "family")
}

func (h *Handler) uploadEntityMedia(c echo.Context, entityType string) error {
    entityID, err := uuid.Parse(c.Param("id"))
    if err != nil {
        return errorResponse(c, http.StatusBadRequest, "INVALID_ID", "Invalid UUID format")
    }

    // Parse multipart form
    file, err := c.FormFile("file")
    if err != nil {
        return errorResponse(c, http.StatusBadRequest, "MISSING_FILE", "File is required")
    }

    // Check file size
    if file.Size > command.MaxFileSize {
        return errorResponse(c, http.StatusRequestEntityTooLarge, "FILE_TOO_LARGE", "File exceeds 10MB limit")
    }

    // Read file content
    src, err := file.Open()
    if err != nil {
        return errorResponse(c, http.StatusInternalServerError, "FILE_ERROR", "Failed to read file")
    }
    defer src.Close()

    fileData, err := io.ReadAll(src)
    if err != nil {
        return errorResponse(c, http.StatusInternalServerError, "FILE_ERROR", "Failed to read file")
    }

    // Get form values
    title := c.FormValue("title")
    if title == "" {
        title = file.Filename
    }
    description := c.FormValue("description")

    // Detect MIME type
    mimeType := file.Header.Get("Content-Type")
    if mimeType == "" {
        mimeType = http.DetectContentType(fileData)
    }

    // Upload via command handler
    input := command.UploadMediaInput{
        EntityType:  entityType,
        EntityID:    entityID,
        Title:       title,
        Description: description,
        Filename:    file.Filename,
        MimeType:    mimeType,
        FileData:    fileData,
    }

    result, err := h.cmdHandler.UploadMedia(c.Request().Context(), input)
    if err != nil {
        if errors.Is(err, command.ErrFileTooLarge) {
            return errorResponse(c, http.StatusRequestEntityTooLarge, "FILE_TOO_LARGE", err.Error())
        }
        if errors.Is(err, command.ErrUnsupportedFormat) {
            return errorResponse(c, http.StatusBadRequest, "UNSUPPORTED_FORMAT", err.Error())
        }
        if errors.Is(err, command.ErrEntityNotFound) {
            return errorResponse(c, http.StatusNotFound, "ENTITY_NOT_FOUND", err.Error())
        }
        return errorResponse(c, http.StatusBadRequest, "UPLOAD_FAILED", err.Error())
    }

    // Get created media for response
    media, _ := h.readStore.GetMedia(c.Request().Context(), result.ID)
    return c.JSON(http.StatusCreated, media)
}

// DownloadMedia handles GET /media/{id}/download
func (h *Handler) DownloadMedia(c echo.Context) error {
    id, err := uuid.Parse(c.Param("id"))
    if err != nil {
        return errorResponse(c, http.StatusBadRequest, "INVALID_ID", "Invalid UUID format")
    }

    media, err := h.readStore.GetMediaWithData(c.Request().Context(), id)
    if err != nil {
        return errorResponse(c, http.StatusInternalServerError, "INTERNAL_ERROR", err.Error())
    }
    if media == nil {
        return errorResponse(c, http.StatusNotFound, "NOT_FOUND", "Media not found")
    }

    c.Response().Header().Set("Content-Disposition", fmt.Sprintf("attachment; filename=%q", media.Filename))
    c.Response().Header().Set("Content-Type", media.MimeType)
    return c.Blob(http.StatusOK, media.MimeType, media.FileData)
}

// GetMediaThumbnail handles GET /media/{id}/thumbnail
func (h *Handler) GetMediaThumbnail(c echo.Context) error {
    id, err := uuid.Parse(c.Param("id"))
    if err != nil {
        return errorResponse(c, http.StatusBadRequest, "INVALID_ID", "Invalid UUID format")
    }

    thumbnail, err := h.readStore.GetMediaThumbnail(c.Request().Context(), id)
    if err != nil {
        return errorResponse(c, http.StatusInternalServerError, "INTERNAL_ERROR", err.Error())
    }
    if thumbnail == nil {
        return errorResponse(c, http.StatusNotFound, "NOT_FOUND", "Thumbnail not found")
    }

    return c.Blob(http.StatusOK, "image/jpeg", thumbnail)
}

// Additional handlers: GetMedia, UpdateMedia, DeleteMedia
// ... (follow same patterns as existing handlers)
```

## 3. Route Registration

Add routes to the Echo router setup:

```go
// Media routes
api.GET("/persons/:id/media", h.ListPersonMedia)
api.POST("/persons/:id/media", h.UploadPersonMedia)
api.GET("/families/:id/media", h.ListFamilyMedia)
api.POST("/families/:id/media", h.UploadFamilyMedia)
api.GET("/media/:id", h.GetMedia)
api.PUT("/media/:id", h.UpdateMedia)
api.DELETE("/media/:id", h.DeleteMedia)
api.GET("/media/:id/download", h.DownloadMedia)
api.GET("/media/:id/thumbnail", h.GetMediaThumbnail)
```

</requirements>

<implementation>

1. Update `internal/api/openapi.yaml` with media tag, paths, and schemas
2. Create or update handler file with media endpoints
3. Register routes in router setup
4. Generate OpenAPI client code if using code generation
5. Run `go build ./internal/api/...`

</implementation>

<verification>
```bash
# Validate OpenAPI spec
npm install -g @redocly/cli
redocly lint internal/api/openapi.yaml

# Build API package
go build ./internal/api/...

# Run API tests
go test ./internal/api/... -v

# Manual test with curl
curl -X POST http://localhost:8080/api/v1/persons/{uuid}/media \
  -F "file=@test.jpg" \
  -F "title=Test Photo"
```
</verification>

<output>
After completing this stage, provide:
1. Endpoints added
2. Multipart handling approach
3. Response formats

Example output:
```
Stage 8 Complete: OpenAPI + HTTP Handlers

OpenAPI spec updated with:
- Tag: media
- 9 endpoints across persons, families, and media resources
- 5 new schemas: MediaType, Media, MediaUpload, MediaUpdate, MediaList

Endpoints:
- GET /persons/{id}/media - list person's media
- POST /persons/{id}/media - upload to person (multipart)
- GET /families/{id}/media - list family's media
- POST /families/{id}/media - upload to family (multipart)
- GET /media/{id} - get metadata
- PUT /media/{id} - update metadata
- DELETE /media/{id} - delete media
- GET /media/{id}/download - download file with Content-Disposition
- GET /media/{id}/thumbnail - get thumbnail (image/jpeg)

Multipart handling:
- Echo's FormFile for file extraction
- http.DetectContentType fallback
- 10MB limit enforced

Build verification: go build passed
OpenAPI validation: passed

Ready for Stage 9 (GEDCOM Integration)
```
</output>
